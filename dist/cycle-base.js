(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.CycleBase = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
;
;
;
;
function makeSinkProxies(drivers, streamAdapter) {
    var sinkProxies = {};
    for (var name in drivers) {
        if (drivers.hasOwnProperty(name)) {
            var holdSubject = streamAdapter.makeHoldSubject();
            var driverStreamAdapter = drivers[name].streamAdapter || streamAdapter;
            var stream = driverStreamAdapter.adapt(holdSubject.stream, streamAdapter.streamSubscribe);
            sinkProxies[name] = {
                stream: stream,
                observer: holdSubject.observer
            };
        }
    }
    return sinkProxies;
}
function callDrivers(drivers, sinkProxies, streamAdapter) {
    var sources = {};
    for (var name in drivers) {
        if (drivers.hasOwnProperty(name)) {
            (function () {
                var driverStreamAdapter = drivers[name].streamAdapter || streamAdapter;
                var adapt = function adapt(stream) {
                    return streamAdapter.adapt(stream, driverStreamAdapter.streamSubscribe);
                };
                sources[name] = drivers[name](sinkProxies[name].stream, adapt, name);
            })();
        }
    }
    return sources;
}
function replicateMany(sinks, sinkProxies, streamAdapter) {
    var results = Object.keys(sinks).filter(function (name) {
        return !!sinkProxies[name];
    }).map(function (name) {
        return streamAdapter.streamSubscribe(sinks[name], sinkProxies[name].observer);
    });
    var disposeFunctions = results.filter(function (dispose) {
        return typeof dispose === 'function';
    });
    return function () {
        disposeFunctions.forEach(function (dispose) {
            return dispose();
        });
    };
}
var isObjectEmpty = function isObjectEmpty(obj) {
    return Object.keys(obj).length === 0;
};
function Cycle(main, drivers, options) {
    if (typeof main !== 'function') {
        throw new Error('First argument given to Cycle must be the \'main\' ' + 'function.');
    }
    if ((typeof drivers === 'undefined' ? 'undefined' : _typeof(drivers)) !== 'object' || drivers === null) {
        throw new Error('Second argument given to Cycle must be an object ' + 'with driver functions as properties.');
    }
    if (isObjectEmpty(drivers)) {
        throw new Error('Second argument given to Cycle must be an object ' + 'with at least one driver function declared as a property.');
    }
    var streamAdapter = options.streamAdapter;
    if (!streamAdapter || isObjectEmpty(streamAdapter)) {
        throw new Error('Third argument given to Cycle must be an options object ' + 'with the streamAdapter key supplied with a valid stream adapter.');
    }
    var sinkProxies = makeSinkProxies(drivers, streamAdapter);
    var sources = callDrivers(drivers, sinkProxies, streamAdapter);
    var sinks = main(sources);
    var run = function run() {
        var disposeReplication = replicateMany(sinks, sinkProxies, streamAdapter);
        return function () {
            streamAdapter.dispose(sinks, sinkProxies, sources);
            disposeReplication();
        };
    };
    return { sinks: sinks, sources: sources, run: run };
}
exports.default = Cycle;


},{}]},{},[1])(1)
});